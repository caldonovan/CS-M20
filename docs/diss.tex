\documentclass{article}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{textcomp}
\usepackage{rotating}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\setmainfont{Minion Pro}

% Layout related commands.
\graphicspath{ {./images/} }
\lstdefinestyle{code}{basicstyle=\ttfamily\footnotesize, breakatwhitespace=false,
    breaklines=true, keywordstyle=\color{magenta}, commentstyle=\color{codegreen},
    keepspaces=true, showspaces=false, showstringspaces=false}
\lstset{style=code}
\pagestyle{fancy}
\fancyhf{}

\rhead{Callum Donovan}
\lhead{Implementing SAT Algorithms in Software}
\rfoot{Page \thepage}
\lfoot{CS-M20 - 1915769}

\title{\bfseries Implementing SAT Algorithms in Software}
\author{Callum Donovan}
\date{September 2020}

\setlength{\parindent}{4em}
\setlength{\parskip}{0.5em}

\begin{document}

\begin{titlepage}
    \begin{center}
        \Large{\bfseries Implementing SAT Algorithms in Software} \\
        \vspace*{\fill}
        \begin{center}
            \includegraphics[scale=0.15]{swan.jpg}
        \end{center}
        \vspace*{\fill}
        \bfseries{\large Callum Donovan \\
            1915769 \\
            September 1, 2020 \\
            Swansea University \\}
    \end{center}
\end{titlepage}

\section{Abstract}
% TODO: Use the word "implement" a lot less!
The Boolean Satisfiability Problem is a fundamental part of Computer Science. First proven to be an
NP-Complete problem by both Stephen Cook in 1971, and Leonid Levin in 1973\cite{dpll}. Since then, many more
NP-Complete problems have been identified, along with their respective uses in the real world
outside of pure computer science. Due to this, there has been a growing need for solvers that can
effectively and efficiently process these problems. In the last two decades alone, huge progress has
been made to coincide with the advancements in technology. And more SAT solvers have appeared that
can be deployed in industries where they are most needed.

This paper explores the basic concept behind SAT solvers, and how they can be implemented in
software using modern programming languages and tools. The algorithm that will be
implemented is one proposed by Donald Knuth in his book "The Art of Computer Programming". Knuth proposes
many algorithms, ranging from the most basic backtracking based algorithm, to an advanced
implementation of WalkSAT[!]. We will explore the fundamentals of how to implement these algorithms,
implement one of them, then test its performance against a suite of SAT problems.

The result of this paper will be a SAT solver implemented in C++, using the data structures and
steps provided by Donald Knuth in his book "The Art of Computer Programming".

\newpage
\tableofcontents

\newpage
\section{Introduction}
% TODO: Refactor to sound better.
Satisfiability has presented itself a huge area of research throughout the history of computer
science. Being the first proved to be NP-Complete in 1971[!], it has been the go-to for complex
computation. And using reduction techniques pioneered in the mid-twentieth century, many other types
of complex problems can be converted into SAT and solved using the plethora of solvers freely
available. In more recent years, SAT competitions have added an incentive to the development of more
advanced solvers, such as Minisat, zChaff, and CaDiCaL. On top of these, parallel solvers have
gained popularity and one such solver, called Plingaling, ranked very highly in the SAT Competition
2020. Showing how parallel solvers can be just as good as their counterparts, if not better.

Donald Knuth has taken particular interest in this topic with his recent chapter of "The Art of Computer Programming". He discusses how important SAT solvers are to both industry and research, as well as providing algorithms and sample problems to test them against.

This paper will be an exploration into the world of SAT solvers and how they can provide crucial services to both industry and research. As well as methods in which proposed SAT solver algorithms can be implemented into a robust piece of software.

\subsection{Motivation}
\begin{itemize}
    \item Discuss how SAT solvers can aid industry.
    \item Discuss how learning about SAT can help other people learn too.
\end{itemize}

\subsection{Aims and Objectives}
\begin{itemize}
    \item To make a SAT solver using instructions from "TAOCP"
    \item Make sure the solver can solve generic problem sets in DIMACS.
    \item Make sure the solver can do this in a decent amount of time.
    \item Basically FREQ1 and FREQ2.
\end{itemize}

\section{Background}
Before we get into the implementation and software, it is always good to have a solid understanding
of the topic at hand. SAT in particular is quite a deep topic, it is easy to spend a long time
researching into all the intricacies[!]. For this paper, we will just be concentrating on the
general concepts and ideas behind 3SAT problems.

\begin{itemize}
    \item Maybe include some complex problem sets here?
\end{itemize}

% TODO: Insert previous CSCM10 research here, cause we ain't doing it again!

\subsection{SAT Fundimentals}
% TODO: Explain the fundamentals of SAT and the people who found it.
\begin{itemize}
    \item Define the SAT problem with reference.
    \item Explain how SAT formulas are constructed.
    \item Explan early attempts to solve SAT formulas.
\end{itemize}

\subsection{3SAT}
\begin{itemize}
    \item Define 3SAT.
    \item Show a problem that would be considered 3SAT.
    \item Explain why 3SAT is of particular interest.
\end{itemize}

\subsection{Modern SAT}
\begin{itemize}
    \item Talk about how SAT has evolved since the original DPLL.
    \item Modern SAT competitions.
    \item Parallel SAT solvers.
\end{itemize}

\section{Related Work}
% TODO: Add related work, such as alternative FOSS solutions.
Moving on from the background of SAT, we can look into existing solutions that are freely available.
As of 2020, there are plenty of FOSS programs that can be used to solve large sets of problems. This
is in part due to the regularity of the SAT competitions that encourage people to build
groundbreaking solvers.

\subsection{Minisat}
A popular and early solver that has won many competitions[!] is Minisat. Written in C++ and boasting
just a mere few hundred lines of code, Minisat has been proven to be an effective tool for medium
sized problem sets. First written in 2003 by Niklas Een[!] and Niklas Sorensson[!], its primary goal
was to help developers and researchers get into the field of SAT solving by providing a simple
interface and minimal codebase.

\begin{itemize}
    \item Talk about Minisat.
    \item Go into detail about offshoots from Minisat, such as CryptoMiniSat.
    \item Newer CDCL algorithms.
    \item Look into SAT 2020 to find some interesting new solvers.
    \item Basically talk about applications then the research currently happening.
\end{itemize}

\subsection{CryptoMiniSat}
As the name suggests, this solver builds upon the foundations laid by Minisat to create an all in
one solution to multiple problems. CryptoMiniSat implements most of the useful features from Minisat
2.0 core, along with PrecoSat and Glucose to try to make a one-stop solution. CryptoMiniSat is still
in active development, hosting their code on GitHub for collaborative

\section{Design}
\begin{itemize}
    \item Summary of what we would want from a design.
    \item Include the algorithm from Donald Knuth.
    \item Discuss the data structures that we will need to implement.
\end{itemize}
% TODO: Talk about how we've design the code based off of the algorithm and preceding content in the book.

\section{Implementation}
\begin{itemize}
    \item Discuss the general idea of the program, including inputs (DIMACS) and outputs (SAT / NON-SAT).
    \item Discuss the process in which we are going to be solving these problems.
    \item Talk about our toolchain and related crap.
    \item Talk about the attempts at implementing it.
    \item Show the final implementation.
\end{itemize}

\subsection{Psuedocode \& Code}
\begin{itemize}
    \item Investigate general psuedocode of generic DPLL algorithm
    \item Create some pseudocode from algorithm.
\end{itemize}

\subsection{Interesting features in C++}
\begin{itemize}
    \item Talk about how C++ can help when creating a program.
    \item Talk about how the standard template library can be used to reduce program complexity.
    \item Talk about the use of vectors as a handy data type over C style types.
\end{itemize}

\subsection{Implementing Data Structures}
\begin{itemize}
    \item Discuss why we're going to have to implement specific data types.
    \item Provide examples on the types of structures to be used.
\end{itemize}
% TODO: Talk about how we are going to implement this. Not so much about the actual implementation itself!

\section{Testing}
\begin{itemize}
    \item Summarize what we want from the testing phase.
    \item Discuss the problem sets that we are going to be throwing at this.
    \item Discuss program testing first, even though this is not really what we mean by "testing".
    \item Record some testing metrics, such as time to solve, memory, CPU cycles, etc.
    \item Describe any regions that could potentially be improved.
\end{itemize}

\subsection{Checking For Correct Solutions}
\begin{itemize}
    \item Add results from test folder
    \item Use two other solvers and give them the same problem
    \item Check at least 10 times to ensure consistent results
\end{itemize}

\subsection{Monitoring Initial Performance Metrics}
\begin{itemize}
    \item Measure the performance of this SAT solver (algorithm we picked?)
    \item Measure the performance of other SAT solvers.
    \item Compare the results and deduce why the performance differences exist.
\end{itemize}
% TODO: Talk about the testing of the implemented code and whether it meets the requirements that we have set previously

\subsection{Improving Performance}
\begin{itemize}
    \item Explore performance implications of algorithm.
    \item Talk about DK's performance predictions from TAOCP.
    \item Talk about how we could potentially improve the performance of our solver.
    \item Maybe talk about things like parallelism?
\end{itemize}

\section{Evaluation}
\begin{itemize}
    \item Discuss our findings statistically.
    \item Discuss how implemented code could be improved (summarise).
    \item Talk about the methodology we used.
    \item Talk about the risks encountered, and the time frame in which we carried this out.
    \item Discuss the things that could potentially be improved if we did the project again.
    \item Discuss the pandemic.
\end{itemize}
% TODO: Talk about the challenges we faced and also what we could improve if doing the project again

\section{Conclusion}
\begin{itemize}
    \item Just make a short summary of every single thing that was typed out above!
    \item Don't forget to basically copy and paste this to the abstract.
\end{itemize}
% TODO: Conclude on our findings and all the preceding work we have done.

\newpage
\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}
