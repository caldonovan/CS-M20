\documentclass{article}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{graphicx}
%\usepackage{amsmath}
%\usepackage{booktabs}
%\usepackage{textcomp}
%\usepackage{rotating}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

% Best font EU don't @ me
\setmainfont{Minion Pro}

% === Colours ===
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
% === End Colours ===

% === Layout ===
\graphicspath{ {./images/} }
\lstdefinestyle{code}{basicstyle=\ttfamily\footnotesize, breakatwhitespace=false,
    breaklines=true, keywordstyle=\color{magenta}, commentstyle=\color{codegreen},
    keepspaces=true, showspaces=false, showstringspaces=false}
\lstset{style=code}
\pagestyle{fancy}
\fancyhf{}

\rhead{Callum Donovan}
\lhead{Implementing SAT Algorithms in Software}
\rfoot{Page \thepage}
\lfoot{CS-M20 - 1915769}
% === End Layout ===

\title{\bfseries Implementing SAT Algorithms in Software}
\author{Callum Donovan}
\date{ \today }

\setlength{\parindent}{4em}
\setlength{\parskip}{0.5em}

\begin{document}

% === Title Page ===
\begin{titlepage}
    \begin{center}
        \Large{\bfseries Implementing SAT Algorithms in Software} \\
        \vspace*{\fill}
        \begin{center}
            \includegraphics[scale=0.15]{swan.jpg}
        \end{center}
        \vspace*{\fill}
        \bfseries{\large Callum Donovan \\
            1915769 \\
            \today \\
            Swansea University \\}
    \end{center}
\end{titlepage}
% === End Title Page ===

% === Main Content ===

\thispagestyle{empty}
\begin{center}
\section*{Abstract}
\end{center}
% TODO: Use the word "implement" a lot less!
The Boolean Satisfiability Problem is a fundamental part of Computer Science. First proven to be an
NP-Complete problem by both Stephen Cook in 1971\cite{scook}, and Leonid Levin in 1973\cite{levin}. Since then, many more
NP-Complete problems have been identified, along with their respective uses in the real world
outside of pure computer science. Due to this, there has been a growing need for solvers that can
effectively and efficiently process these problems. In the last two decades alone, huge progress has
been made to coincide with the advancements in technology. And more SAT solvers have appeared that
can be deployed in industries where they are most needed.

This paper explores the basic concept behind SAT solvers, and how they can be implemented in
software using modern programming languages and tools. The algorithm that will be
implemented is one proposed by Donald Knuth in his book "The Art of Computer Programming". Knuth proposes
many algorithms, ranging from the most basic backtracking based algorithm, to an advanced
implementation of WalkSAT[!]. We will explore the fundamentals of how to implement these algorithms,
implement one of them, then test its performance against a suite of SAT problems.

The result of this paper will be a SAT solver implemented in C++, using the data structures and
steps provided by Donald Knuth in his book "The Art of Computer Programming".

\newpage
\thispagestyle{empty}
\tableofcontents

\newpage
\section{Introduction}
% TODO: Refactor to sound better.
% TODO: Add some examples to interest the reader.
Satisfiability has presented itself a huge area of research throughout the history of computer
science. Being the first proved to be NP-Complete in 1971\cite{scook}, it has been the go-to for complex
computation. And using reduction techniques pioneered in the mid-twentieth century, many other types
of complex problems can be converted into SAT and solved using the plethora of solvers freely
available. In more recent years, SAT competitions have added an incentive to the development of more
advanced solvers, such as Minisat, zChaff, and CaDiCaL. On top of these, parallel solvers have
gained popularity and one such solver, called Plingaling, ranked very highly in the SAT Competition
2020. Showing how parallel solvers can be just as good as their counterparts, if not better.

Donald Knuth has taken particular interest in this topic with his recent chapter of "The Art of Computer Programming". He discusses how important SAT solvers are to both industry and research, as well as providing algorithms and sample problems to test them against.

This paper will be an exploration into the world of SAT solvers and how they can provide crucial services to both industry and research. As well as methods in which proposed SAT solver algorithms can be implemented into a robust piece of software. Due to the sheer size of literature and research in this field, it would be unrealistic to think it is possible to cover everything in a comprehensive way. Therefore, this paper focuses on the fundamentals of SAT and the significant research through the years since Cooks paper in 1971\cite{scook}. As well as the ideas presented by Donald Knuth for implementation in modern programming languages.

\subsection{Motivation}
\begin{itemize}
    \item Discuss how SAT solvers can aid industry.
    \item Discuss how learning about SAT can help other people learn too.
\end{itemize}

The motivation behind this project stems from the ever growing need for more efficient and faster SAT solvers. But in order to begin researching in this field, one must know the basics and tried methods present today. This project will do just that, in both studying literature that has formed the basis of most of the field, and implementing a basic SAT solver.

One of the most common arguments for the research into SAT solving is its viability for both science and industry. This presents a convenient compatibility between the two. As industry requirements grow, so too does the need for research into better algorithms to satisfy those requirements. An example in which SAT solvers are a key part of industry include Electronic Design Automation (or EDA). We will explore these usages further as we progress and highlight the advantages of fast SAT solvers when applied to these industries.

Another common viability for SAT solvers includes their usage for most complex problems that can be reduced to SAT. Most problems in the real world can be cast as optimisation problems. This allows us to create a mathematical description of these problems, which in turn can present themselves for solving. The use of a solver in this instance would produce results which would allow for cost-saving or general efficiency improvements.

\subsection{Aims and Objectives}
% TODO: Refactor this section, especially the DK bit.
To preface this project we must present the aims and objectives that we wish to aim for. As explained above, we do not wish to push the boundaries of SAT solvers in this particular project. But instead want to explore the basics and expand on current research. Aiding us in this goal will be the series by Donald Knuth, "The Art of Computer Programming". Knuth has recently taken interest in the concept of satisfiability for "Fascicle 6: Satisfiability" , and presents a large amount of content for us to analyse. In this book, Knuth outlines multiple algorithms that could be used to implement multiple common SAT solvers. These include:

\begin{itemize}
    \item Algorithm B - Backtracking with watched literals.
    \item Algorithm D - DPLL.
    \item Algorithm C - CDCL.
    \item Algorithm L - DPLL with lookahead.
    \item Algorithm W - WalkSAT.
\end{itemize}

% Be careful of the spell checker attempting to "americani(z)e" everything.
We shall be analysing each of these algorithms and presenting the data structures needed and methods of implementation using C++. Once our implementation is complete, and testing has proved the solver to be working as intended, we will record the performance metrics in a scientific manner to ensure accuracy. These metrics will then be compared to other FOSS solvers that are well tested and commonly used. This will give us a benchmark as to how increasing complexity of the algorithm and program can achieve greater performance. As well as how the programming language chosen can effect the overall performance.

We can easily turn these actions into functional and non-functional requirements. Doing so will allow us to test against the requirements stated and compare the expected result to the actual result. This format matches a more "software engineering" approach, which is desired for this project.

\subsubsection{FREQ1}
The resulting software should be able to process and input CNF formula in the semi-standard DIMACS format.

\subsubsection{FREQ2}
The resulting software should be able to evaluate the satisfiability of a simple formula from FREQ1, and return the result when found. Simple refers to a formula which most SAT solvers would be able to process in a short amount of time. Result refers to the decision returned from the solver that concludes as "SATISFIABLE" or "UNSATISFIABLE".

\subsubsection{Non-Functional Requirements}
These requirements differ from functional requirements as they are not crucial to the project's success. These are simply goals that, if time allows, can be implemented for further data.

\subsubsection{NFREQ1}
The resulting software should be able to process a complex formula within a reasonable amount of time. Reasonable refers to the length of time it takes to return a result when compared to other SAT solvers, i.e. 300 seconds to return "SATISFIABLE".

%\begin{itemize}
%    \item To make a SAT solver using instructions from "TAOCP"
%    \item Make sure the solver can solve generic problem sets in DIMACS.
%    \item Make sure the solver can do this in a decent amount of time.
%    \item Basically FREQ1 and FREQ2.
%\end{itemize}

\section{Background}
Before we get into the implementation and software, it is always good to have a solid understanding
of the topic at hand. SAT in particular is quite a deep topic, it is easy to spend a long time
researching into all the intricacies[!]. For this paper, we will just be concentrating on the
general concepts and ideas behind 3SAT problems.

\begin{itemize}
    \item Maybe include some complex problem sets here?
\end{itemize}

% TODO: Insert previous CSCM10 research here, cause we ain't doing it again!

\subsection{SAT Fundamentals}
% TODO: Explain the fundamentals of SAT and the people who found it.
\begin{itemize}
    \item Define the SAT problem with reference.
    \item Explain how SAT formulas are constructed.
    \item Explain early attempts to solve SAT formulas.
    \item Discuss the DPLL algorithm, the first computer implementation of a solver.
\end{itemize}

\subsection{3SAT}
\begin{itemize}
    \item Define 3SAT.
    \item Show a problem that would be considered 3SAT.
    \item Explain why 3SAT is of particular interest.
\end{itemize}

\subsection{Modern SAT}
\begin{itemize}
    \item Talk about how SAT has evolved since the original DPLL.
    \item Modern SAT competitions.
    \item Parallel SAT solvers.
    \item General future SAT solver stuff.
\end{itemize}

\section{Related Work}
% TODO: Add related work, such as alternative FOSS solutions.
Moving on from the background of SAT, we can look into existing solutions that are freely available.
As of 2020, there are plenty of FOSS programs that can be used to solve large sets of problems. This
is in part due to the regularity of the SAT competitions that encourage people to build
groundbreaking solvers.

\subsection{Minisat}
A popular and early solver that has won many competitions[!] is Minisat. Written in C++ and boasting
just a mere few hundred lines of code, Minisat has been proven to be an effective tool for medium
sized problem sets. First written in 2003 by Niklas Een[!] and Niklas Sorensson[!], its primary goal
was to help developers and researchers get into the field of SAT solving by providing a simple
interface and minimal codebase.

\begin{itemize}
    \item Talk about Minisat.
    \item Go into detail about offshoots from Minisat, such as CryptoMiniSat.
    \item Newer CDCL algorithms.
    \item Look into SAT 2020 to find some interesting new solvers.
    \item Basically talk about applications then the research currently happening.
\end{itemize}

\subsection{CryptoMiniSat}
As the name suggests, this solver builds upon the foundations laid by Minisat to create an all in
one solution to multiple problems. CryptoMiniSat implements most of the useful features from Minisat
2.0 core, along with PrecoSat and Glucose to try to make a one-stop solution. CryptoMiniSat is still
in active development, hosting their code on GitHub for open collaboration.

% TODO: Add more current SAT solvers.

\section{Design}
\begin{itemize}
    \item Summary of what we would want from a design.
    \item Include the algorithm from Donald Knuth (algorithm D).
    \item Discuss the data structures that we will need to implement based off of DK's ideas.
\end{itemize}

\subsection{Algorithm}
The key to all the most successful SAT solvers are the algorithms. The first SAT solver to be implemented for a computer used the DPLL algorithm. As we previously established, the DPLL algorithm is considered one of the firsts and produced good results for the time. As of 2020, there have been a plethora of improvements to the original DPLL algorithm that has allowed it to keep up with the increasing complexity of problems available. The general pseudocode for the original DPLL algorithm can be written as such:

\begin{figure}
% TODO: Put the DPLL algorithm pseudocode here
% ! FIX THIS
\begin{lstlisting}[language=C++]
    Algorithm DPLL
        Input: A set of clauses C
        Output: A truth value

    Function DPLL(C)
        if C is a consistent set of literals then
            return true;
        if C contains an empty clause then
            return false;
        for every unit clause {L} in C do
            C ← unit-propagate(L, C);
        for every literal L that occurs pure in C do
            C ← pure-literal-assign(L, C);
        L ← choose-literal(C);
        return DPLL(C ∧ {L}) or DPLL(C ∧ {not(L)});
\end{lstlisting}    
\end{figure}

For our project, the algorithm that we will be interested in is a general DPLL algorithm. As previously discussed, this is just one of a few algorithms given from Donald Knuth. Although it is relatively simple, it is a good way to explore the basic idea of software SAT solvers. Forming a foundation for further improvements, much like those explained in algorithm L. Donald Knuth describes the algorithm in a series of steps, also outlining the data structures that we need to implement it as he has described. 


\begin{itemize}
    \item Discuss algorithms presented by DK.
    \item Discuss which algorithm we are planning to implement.
    \item Talk about the ones we aren't going to anyway?
\end{itemize}
% TODO: Talk about how we've design the code based off of the algorithm and preceding content in the book.

\section{Implementation}
\begin{itemize}
    \item Discuss the general idea of the program, including inputs (DIMACS) and outputs (SAT / NON-SAT).
    \item Discuss the process in which we are going to be solving these problems.
    \item Talk about our tool-chain and related crap.
    \item Talk about the attempts at implementing it.
    \item Show the final implementation.
\end{itemize}

% These are the basic steps of a computer program.
% Explain to the reader what is included for SAT.
\subsection{Input}
\begin{itemize}
    \item The input will be a CNF formula in the DIMACS file format.
\end{itemize}

\subsection{Processing}
\begin{itemize}
    \item Discuss how the processing works.
    \item This is the real meat that basically explains the algorithm.
    \item I feel it would be best to at least discuss the DPLL algorithm.
    \item Use content from TAOCP and online.
\end{itemize}

\subsection{Output}
% https://web.archive.org/web/20190913185210/http://www.satcompetition.org:80/2004/format-solvers2004.html
\begin{itemize}
    \item The output will be "SATISFIABLE" or "NOT SATISFIABLE".
    \item Could also output the best solution.
    \item Explain the output standard for SAT competitions.
    \item SAT Competition 2002 output rules (see above comment).
\end{itemize}

% This is going to be pretty important, attempt to simplify for the reader.
\subsection{Data Structures}
\begin{itemize}
    \item Discuss why we're going to have to implement specific data types.
    \item Provide examples on the types of structures to be used.
\end{itemize}

\subsection{Tool-chain}
\begin{itemize}
    \item Discuss the compiler and standard libraries
    \item Discuss the editor and debugger used.
    \item Discuss the OS \& related things (such as shell).
\end{itemize}

\subsubsection{Compiler \& Libraries}
There are multiple compilers available for C++ dependant on the platform. Generally for each of the three most common platforms (Windows, Linux, and MacOS) there are reliable and well tested compiler suites available. The GNU Compiler Collection, or GCC, is considered one of the standard compiler suites for C and C++. GCC has implementations for each of the aforementioned platforms via ports. The Windows implementation in particular is included in a few software development environments that are freely available; MinGW, MSYS2, and Cygwin.

As for Linux, the GCC suite can be installed natively typically using the preferred distro's package manager. For this project the code will be compiled on a Debian based system using the GCC suite. Linux provides a simpler method of developing using C / C++ and streamlines the time from development to testing. Alongside this, the included GDB debugger allows for a simple and lightweight debugging solution. We will also be making use of bash scripts to invoke the software and provide flags to control options, something that can be a little more challenging on a Windows machine. 

No development will be carried out on a Macintosh as we simply do not have access to one. Typically these types of software are compiled and run using a Linux system, and thus it would make the most sense to follow the given norm.

\subsubsection{Editor \& Environment}
There are a huge swathe of IDE's and editors available for use and as for which one to use, there isn't a definitive answer. We thought that it would be best to just stick with what we know best, and for this instance that would be Visual Studio Code. Although other IDE's are available that can take a lot of the work out of managing a project. It is not really necessary to use one here. This project will not contain a huge amount of code or files, and general debugging and profiling does not need to be done using bloated IDE's. Visual Studio Code contains a massive inventory of extensions available to give an experience just as rich as an IDE, but without the cumbersome nature of one. As for this project we only need a single extension to get the required development environment: 

\begin{itemize}
    \item C / C++ -> 1.0
\end{itemize}

It is also important to mention any other environment software aside from the previously mentioned. We are going to be using the \texttt{'time'} command to accurately measure the time metrics of the software from start to completion. This command is available through bash and is invoked at the same time as the program itself. An example of the method in which it can be invoked is as follows: 

% TODO: Put the time command here to demonstrate invocation. 



\subsection{Pseudocode \& Code}
\begin{itemize}
    \item Investigate general pseudocode of generic DPLL algorithm (Wiki).
    \item Create some pseudocode from algorithm.
    \item Create some actual code to show?
\end{itemize}
% TODO: Talk about how we are going to implement this. Not so much about the actual implementation itself!

\section{Testing}
\begin{itemize}
    \item Summarize what we want from the testing phase.
    \item Discuss the problem sets that we are going to be throwing at this.
    \item Discuss program testing first, even though this is not really what we mean by "testing".
    \item Record some testing metrics, such as time to solve, memory, CPU cycles, etc.
    \item Describe any regions that could potentially be improved.
\end{itemize}

\subsection{Software Testing}
\begin{itemize}
    \item Discuss methods of software testing (Unit, manual, etc...)
    \item Outline a testing table for manual testing.
    \item Discuss testing against the functional requirements stated previously.
\end{itemize}

\subsection{Checking For Correct Solutions}
\begin{itemize}
    \item Add results from test folder
    \item Use two other solvers and give them the same problem
    \item Check at least 10 times to ensure consistent results
\end{itemize}

\subsection{Monitoring Initial Performance Metrics}
\begin{itemize}
    \item Measure the performance of this SAT solver (algorithm we picked?)
    \item Measure the performance of other SAT solvers.
    \item Compare the results and deduce why the performance differences exist.
    \item Explain the use of the \texttt{'time'} command with special format.
\end{itemize}
% TODO: Talk about the testing of the implemented code and whether it meets the requirements that we have set previously

\subsection{Improving Performance}
\begin{itemize}
    \item Explore performance implications of algorithm.
    \item Talk about DK's performance predictions from TAOCP.
    \item Talk about how we could potentially improve the performance of our solver.
    \item Maybe talk about things like parallelism?
\end{itemize}

\section{Evaluation}
\begin{itemize}
    \item Discuss our findings statistically.
    \item Discuss how implemented code could be improved (summarise).
    \item Talk about the methodology we used.
    \item Talk about the risks encountered, and the time frame in which we carried this out.
    \item Discuss the things that could potentially be improved if we did the project again.
    \item Discuss the pandemic.
\end{itemize}
% TODO: Talk about the challenges we faced and also what we could improve if doing the project again

\section{Conclusion}
\begin{itemize}
    \item Just make a short summary of every single thing that was typed out above!
    \item Don't forget to basically copy and paste this to the abstract.
\end{itemize}
% TODO: Conclude on our findings and all the preceding work we have done.

% === End Main Content ===

\newpage
\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}
